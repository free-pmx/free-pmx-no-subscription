#!/bin/bash

# SPDX-FileCopyrightText: Copyright 2025 free-pmx
# SPDX-License-Identifier: AGPL-3.0-only

init_out() {

    trap 'exit 255' ERR

    [[ -v FD_USRERR ]] || exec {FD_USRERR}>&2
    [[ -v FD_DEBUG ]] || exec {FD_DEBUG}> "${FREE_PMX_DBGLOG:-/dev/null}"

    [[ $FD_USRERR =~ ^[0-9]+$ ]] && [[ $FD_DEBUG =~ ^[0-9]+$ ]]
    exec 2>&$((FD_DEBUG))

    declare -rgx FD_USRERR FD_DEBUG

    declare -rgA FD_MAP=([OUT]=1 [ERR]=${FD_USRERR:-2} [DBG]=${FD_DEBUG:-2})

    trap - ERR

}

print() {

    [[ -n $1 ]] && declare -r type="$1" || return 255
    declare text="${2:-}"

    declare -ri fd=${FD_MAP[$type]:-1}

    if [[ $text == $'\e' ]]; then
        cat >&$fd
    else
        [[ $text == *$'\e' ]] || text+=$'\n'
        printf >&$fd "%s" "$text"
    fi

}

checksum() {

    [[ -n $1 ]] && declare file=$1 || return 255
    declare algo=${2:-256} || return 255

    declare sum
    declare -i err

    sum=$(
        shasum --algorithm "$algo" "$file" | awk '{print $1}'
        exit $((PIPESTATUS[0] | PIPESTATUS[1]))
    )
    ! ((err = $?)) || unset sum

    echo "$sum"
    return $((err))

}

slurp() {

    [[ -n $1 ]] && declare file=$1 || return 255
    [[ -n $2 ]] && declare vname=$2 || return 255

    { IFS='' read -d '' -r "$vname" || :; } < "$file" || return 1

    [[ -n ${!vname} ]] || return 2

}

source_kv() {

    [[ -n $1 ]] && declare file=$1 || return 255
    [[ -n $2 ]] && declare -n _kv && _kv=$2 && [[ ${_kv@a} == *A* ]] && _kv[err]=255 || return 255
    [[ -n $3 ]] && declare -a vnames_list=("${@:3}") || return 255

    source <(
        source "$file" &> /dev/null
        declare -i err=$?
        declare vname
        for vname in "${vnames_list[@]}"; do
            printf "_kv[%s]=%q\n" "$vname" "${!vname}"
        done
        echo "_kv[err]=$err"
    ) || return 1

    return $((_kv[err]))

}

check_kv_allset() {

    [[ -n $1 ]] && declare -n _kv && _kv=$1 && [[ ${_kv@a} == *A* ]] || return 255
    [[ -n $2 ]] && declare -a keys_list=("${@:2}") || return 255

    declare key
    for key in "${keys_list[@]}"; do
        [[ -n ${_kv[$key]} ]] || return 1
    done

}

apt_policy_match() {

    [[ -n $1 ]] && declare -x uri=$1 || return 255
    [[ -n $2 ]] && [[ -n $3 ]] && declare -x suite_component="$2/$3" || return 255

    apt-cache policy | perl -ne '
        print $1 and last if
        /^\s([0-9]+ $ENV{uri} $ENV{suite_component} .*) Packages$/
    '

    ! ((PIPESTATUS[0] | PIPESTATUS[1])) || return 1

}

deb_last_le_version() {

    [[ -n $1 ]] && declare package=$1 || return 255
    [[ -n $2 ]] && declare vsequence=$2 || return 255

    declare -a versions
    IFS=';' read -r -a versions <<< "$vsequence"

    declare v
    v=$(dpkg-query --show --showformat='${Version}\n' "$package") \
        || return 1

    declare -i i
    for ((i = 0; i < ${#versions[@]}; i++)); do
        dpkg --compare-versions "$v" ge "${versions[$i]}" \
            || break
    done

    ((i > 0)) || return 2

    echo "${versions[$((i - 1))]}"

}

subst_props() {

    [[ -n $1 ]] && declare -n props && props=$1 && [[ ${props@a} == *A* ]] || return 255
    [[ -n $2 ]] && declare -a pnames=("$@") || return 255

    declare -a vnames=()
    declare pname
    for pname in "${pnames[@]}"; do
        [[ -n $pname ]] || return 255
        declare "__${pname}__"="${props[$pname]}"
        vnames+=("__${pname}__")
    done

    declare vname
    for vname in "${vnames[@]}"; do declare -x "$vname"; done
    declare -x SUBST_VNAMES="${vnames[*]}"

    perl -pe '
        BEGIN {
            @s = split / /, "$ENV{SUBST_VNAMES}";
            $j = join "|", @s;
            $m = qr/($j)/;
        }
        s/$m/$ENV{$1}/g;
    '

}

subst_rawblock() {

    [[ -n $1 ]] && declare -n _block=$1 && [[ ${_block@a} == *A* ]] || return 255

    export SUBST_ORIG=${_block[ORIG]}
    export SUBST_REPL=${_block[REPL]}

    perl -p0e '
        BEGIN {
            $o = quotemeta($ENV{SUBST_ORIG});
            $r = $ENV{SUBST_REPL};
        }
        s/$o/$r/;
    '

}
